# head first 设计模式学习笔记

## 策略模式：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
- 针对接口编程，而不是针对实现编程
- 多用组合，少用继承

## 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并且自动更新。
- 为了交互对象之间的松耦合设计而努力

## 装饰者模式：动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。具体参见装饰者.png
- 类应该对扩展开放，对修改关闭
> 装饰者和被装饰着有相同的超类型；你可以用一个或多个装饰者包装一个对象；既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象的场合，
可以用装饰过的对象提到他；装饰者可以在所委托被装饰者的行为之前/后，加上自己的行为，以达到特定的目的；对象可以在任何时候被装饰，所以可以在运行时
动态的、不限量的用你喜欢的装饰者装饰对象。
- 装饰者该做的事，就是增加行为到被包装对象上，当需要窥视装饰者链中的每一个装饰者时，这就超出了他的职责。
- java I/O是jdk的针对装饰者模式的实现，均继承InputStream抽象类，FilterInputStream是装饰者的基类，FileInputStream等直接继承InputStream的类是被装饰类
具体参见装饰者java.io类.png

## 工厂模式：定义了一个创建对象接口，但由子类决定要实例化的类是哪一个。工厂方法让类实例化推迟到子类。具体类结构参见图工厂模式.png
- 工厂方法是由两个平行抽象类：产品类和创建者类以及他们的具体子类构成。产品类继承与抽象产品或者产品接口用于用户定义自定义的产品，创建者类
继承或者实现抽象创建者，实现创建产品的功能，负责创建一个或多个产品

-------------------------------------------------------------------------
2019年5月14日 08:26:12 62/677
2019年5月14日 18:17:00 101/677
2019年5月14日 21:33:08 116/677
2019年5月16日 08:31:20 140/677
2019年5月16日 17:52:09 154/677
2019年5月16日 22:38:36 174/677